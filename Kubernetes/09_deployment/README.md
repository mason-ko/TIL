# 디플로이먼트: 선언적 애플리케이션 업데이트

## 목차

- [9.1 파드에서 실행 중인 애플리케이션 업데이트](#91-파드에서-실행-중인-애플리케이션-업데이트)
  - [9.1.1 오래된 파드를 삭제하고 새 파드로 교체](#911-오래된-파드를-삭제하고-새-파드로-교체)
  - [9.1.2 새 파드 기동과 이전 파드 삭제](#912-새-파드-기동과-이전-파드-삭제)
- [9.2 레플리케이션컨트롤러로 자동 롤링 업데이트 수행](#92-레플리케이션컨트롤러로-자동-롤링-업데이트-수행)
  - [9.2.1 애플리케이션의 초기 버전 실행](#921-애플리케이션의-초기-버전-실행)
  - [9.2.2 kubectl을 이용한 롤링 업데이트](#922-kubectl을-이용한-롤링-업데이트)
  - [9.2.3 kubectl rolling-updateS 더 이상 사용하지 않는 이유](#923-kubectl-rolling-updates-더-이상-사용하지-않는-이유)
- [9.3 애플리케이션을 선언적으로 업데이트하기 위한 디플로이먼트 사용하기](#93-애플리케이션을-선언적으로-업데이트하기-위한-디플로이먼트-사용하기)
  - [9.3.1 디플로이먼트 생성](#931-디플로이먼트-생성)
  - [9.3.2 디플로이먼트 업데이트](#932-디플로이먼트-업데이트)
  - [9.3.3 디플로이먼트롤백](#933-디플로이먼트롤백)
  - [9.3.4 롤아웃 속도 제어](#934-롤아웃-속도-제어)
  - [9.3.5 롤아웃 프로세스 일시 중지](#935-롤아웃-프로세스-일시-중지)
  - [9.3.6 잘못된 버전의 롤아웃 방지](#936-잘못된-버전의-롤아웃-방지)
- [9.4 요약](#94-요약)

## 9.1 파드에서 실행 중인 애플리케이션 업데이트
<img width="435" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/e56820e5-a94a-4092-a500-6c61d9dec9aa">

파드를 업데이트 하는 방법
- 기존 파드를 모두 삭제한 다음 새 파드를 시작
  - 장점: 한가지 버전으로 가능 
  - 단점: 중단 시간 있음 
- 새로운 파드를 시작하고, 기동하면 기존 파드를 삭제, 점진적으로 제거
  - 장점: 무중단 
  - 단점: 두가지 버전 호환 

### 9.1.1 오래된 파드를 삭제하고 새 파드로 교체
<img width="772" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/e672172b-764a-41e9-a6a4-2aa5e5196a08">
간단하지만 다운타임이 있다.

### 9.1.2 새 파드 기동과 이전 파드 삭제
다운타임이 발생하지 않고 변경 시 두배의 파드가 실행되므로 더 많은 하드웨어 리소스가 필요.  

#### 한번에 이전 버전에서 새 버전으로 전환
블루-그린 배포 전략(Blue-Green Deployment)은 새로운 버전의 애플리케이션을 안전하게 배포하는 전략 중 하나입니다. 기본 아이디어는 동시에 두 개의 동일한 프로덕션 환경(블루와 그린)을 유지하면서 한 환경에는 현재 버전(예: 블루)을, 다른 환경에는 새 버전(예: 그린)을 배포하는 것입니다. 배포가 완료되면 트래픽을 새로운 버전으로 전환하여 서비스 중단 시간 없이 신규 버전을 활성화합니다.  
<img width="772" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/9be2b621-4f05-4a84-8382-ebca932d6e79">

#### 롤링 업데이트 수행 
롤링 업데이트(Rolling Update)는 쿠버네티스(Kubernetes)에서 애플리케이션의 새로운 버전을 점진적으로 배포하는 전략입니다. 롤링 업데이트는 서비스 중단 없이 애플리케이션을 업데이트하는 데 유용하며, 모든 인스턴스를 동시에 업데이트하는 대신 일부 인스턴스를 새 버전으로 점진적으로 교체합니다.  
- 롤링 업데이트의 장점:
  - 중단 시간 없음: 롤링 업데이트는 애플리케이션의 가용성을 유지하면서 새 버전을 점진적으로 배포합니다.
  - 자원 효율성: 블루-그린 배포와 달리 롤링 업데이트는 추가적인 인프라나 환경을 요구하지 않습니다.
  - 자동 롤백: 설정에 따라 쿠버네티스는 업데이트 중 문제가 발생하면 자동으로 롤백할 수 있습니다.
- 롤링 업데이트의 단점:
  - 교차 버전 문제: 롤링 업데이트 도중에 두 버전의 애플리케이션이 동시에 실행될 수 있습니다. 이로 인해 호환성 문제가 발생할 수 있습니다.
  - 느린 배포: 큰 클러스터에서는 롤링 업데이트가 시간이 오래 걸릴 수 있습니다.

## 9.2 레플리케이션컨트롤러로 자동 롤링 업데이트 수행
### 9.2.1 애플리케이션의 초기 버전 실행
```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: kubia-v1
spec:
  replicas: 3
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers: 
      - image: luksa/kubia:v1 # 이 이미지를 실행하는 파드에 대한 레플리케이션컨트롤러를 
        name: nodejs   # 만들고 있다.
--- # yaml 파일에는 대시 3개가 있는 줄로 구분해 여러 리소스 정의를 포함할 수 있다. 
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  type: LoadBalancer
  selector:
    app: kubia
  ports:
  - port: 80
    targetPort: 8080
```

### 9.2.2 kubectl을 이용한 롤링 업데이트
이미지 변경 배포 이후 
```
$ kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2

$ kubectl describe rc kubia-v2 
```

<img width="748" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/4e5d96e0-f535-445f-ab86-26037d8fb22c">


### 9.2.3 kubectl rolling-update를 더 이상 사용하지 않는 이유
이 명령어는 쿠버네티스의 새로운 기능들과 더 나은 업데이트 매키너짐을 제공하기 위해 중단되었다.  
대신 kubectl rollout 서브 커맨드가 도입됨.  

1. 기능제한: 'kubectl rolling-update'는 RC 만 지원했다.
2. 복잡성: 롤링 업데이트를 수행하는데 필요한 여러단계들이 있었고, 휴면에러 발생요인 큼
3. 디플로이먼트 리소스의 등장: 디플로이먼트로, 선언적업데이트, 롤링업데이트 등 진보된 기능을 제공하므로 이걸 사용하면 됨.
4. 선언적 업데이트: kubectl rollout 와 함께 사용되는 디플로이먼트는 선언적 접근방식을 사용하여 워크로드의 상태를 지정할 수 있다. 이는 워크로드의 원하는 상태를 명시적으로 정의하고, 쿠버네티스가 이 상태를 달성하기 위해 필요한 조치를 자동으로 수행하도록 허용한다.

## 9.3 애플리케이션을 선언적으로 업데이트하기 위한 디플로이먼트 사용하기
디플로이먼트는 낮은 수준의 개념으로 간주되는 RC, 레플리카셋을 통해 수행하는 대신 애플리케이션을 배포하고  
선언적으로 업데이트하기 위한 높은 수준의 리소스다.  
레플리카셋도 파드를 복제하고 관리한다.  
디플로이먼트를 사용하는 경우 실제 파드는 디플로이먼트가 아닌 디플로이먼트의 레플리카셋에 의해 생성되고 관리된다.
<img width="427" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/b3f3df30-1189-48f3-93ca-0903d43807da">


### 9.3.1 디플로이먼트 생성
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubia # 디플로이먼트이름에 버전을 포함할 필요 없음
spec:
  replicas: 3
  template:
    metadata:
      name: kubia
      labels:
        app: kubia
    spec:
      containers:
      - image: luksa/kubia:v1
        name: nodejs
  selector:
    matchLabels:
      app: kubia
```
#### 디플로이먼트 리소스 생성 
<img width="613" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/4bfb20ad-9ae7-49c0-99ef-daa35a7f2f4b">

```
$ kubectl rollout status deployment kubia
$ kubectl get po
```
#### 디플로이먼트가 레플리카셋을 생성하는 방법과 레플리카셋이 파드를 생성하는 방식 이해 
1. 디플로이먼트 (Deployment):
- 디플로이먼트는 상위 레벨의 오브젝트로, 애플리케이션의 선언적 업데이트와 롤백을 제공합니다.
- 디플로이먼트를 생성하면, 해당 디플로이먼트는 레플리카셋을 생성합니다.
- 디플로이먼트 스펙에 정의된 파드 템플릿을 사용하여 레플리카셋을 생성합니다.
- 디플로이먼트를 업데이트하면 (예: 이미지 버전 변경), 새 레플리카셋이 생성되고 이전 레플리카셋은 점차 셧다운됩니다. 이는 롤링 업데이트 전략을 사용하여 수행됩니다.
2. 레플리카셋 (ReplicaSet):
- 레플리카셋은 파드의 원하는 수량을 유지하는 역할을 합니다. 이 수량은 레플리카셋의 스펙에 정의되어 있습니다.
- 레플리카셋은 디플로이먼트에 의해 간접적으로 관리되지만, 사용자는 직접 레플리카셋을 생성하고 관리할 수도 있습니다. 그러나 일반적으로 이것은 권장되지 않습니다.
- 레플리카셋이 파드를 생성할 때, 디플로이먼트에서 받은 파드 템플릿을 사용합니다.
- 레플리카셋은 항상 파드의 수를 원하는 수량으로 유지하기 위해 작동합니다. 파드가 충돌하거나 삭제되면, 레플리카셋은 새 파드를 생성하여 이를 보완합니다.
3. 파드 (Pod):
- 파드는 쿠버네티스 클러스터에서 컨테이너를 실행하는 기본 단위입니다.
- 레플리카셋은 파드 템플릿을 바탕으로 파드를 생성하며, 이 템플릿은 디플로이먼트에서 상속받습니다.
- 파드는 클러스터의 노드에서 실제로 실행되는 컨테이너의 집합체입니다.

```
$ kubectl get replicasets
```
#### 서비스로 파드 액세스 
이전에 생성한 서비스로 액세스 가능.

### 9.3.2 디플로이먼트 업데이트
Recreate전략: 새파드를 만들기 전에 이전파드를 모두 삭제. (다운타임발생)
롤링업데이트 전략: 이전 파드를 하나씩 제거하고 동시에 새 파드를 추가해 다운타임 없도록 함.
- 다만 이번 버전과 새 버전이 동시 호환 되는 경우에만 가능.

#### 데모 목적으로 롤링 업데이트 속도 느리게 하기 
minReadySeconds 속성값으로 느리게 업데이트 가능.  
```
$ kubectl patch deployment kubia -p '{"spec": {"minReadySeconds": 10}}' "kubia" patched
```
명령어로 파드 템플릿 이미지 변경 
```
$ kubectl set image deployment kubia nodejs=luksa/kubia:v2
deployment "kubia" image updated
```
<img width="613" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/ef46482c-de53-48c4-93ea-be29de828ce4">

#### 디플로이먼트와 그 외의 리소스 수정하는 방법
<img width="574" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/ae86ba80-632a-43db-98b9-718359fe8578">
<img width="563" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/8da8771e-0933-4e53-aee8-f28688d1a2ea">

<img width="692" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/0d0f91df-a56d-4902-abc9-9e9004a8ba63">


### 9.3.3 디플로이먼트롤백
현재 v2 기준으로 v3 준비.(v3 에러버전)  
v3 배포  
```
$ kuberctl set image deployment kubia nodejs=luksa/kubia:v3
```
에러 발생.  
#### 롤아웃 되돌리기
마지막 롤아웃 취소해서 이전 버전으로 쉽게 돌릴 수 있다.  
```
$ kubectl rollout undo deployment kubia
```
#### 특정 디플로이먼트 개정으로 롤백 
```
$ kubectl rollout undo deployment kubia --to-revision=1
```

### 9.3.4 롤아웃 속도 제어
쿠버네티스(Kubernetes)에서 롤아웃 속도를 제어해야 하는 여러 가지 이유가 있습니다:

- 자원 사용 최적화: 빠르게 롤아웃을 하면 자원(CPU, 메모리 등)을 과도하게 사용할 가능성이 있습니다. 이는 다른 작업에 영향을 줄 수 있습니다.
- 서비스 안정성: 롤아웃이 너무 빠르게 이루어지면, 잠재적인 버그나 이슈를 확인하기 어렵습니다. 속도를 제어하면 문제가 발생할 경우 더 쉽게 대응할 수 있습니다.
- 로드 밸런싱: 새로운 버전의 애플리케이션으로의 트래픽을 점진적으로 늘리는 것이 서비스의 안정성을 유지할 수 있습니다.
- 카나리 테스트: 롤아웃 속도를 제어하면 일부 사용자에게만 새로운 기능을 노출시켜 효과를 테스트할 수 있습니다.
- 롤백 용이성: 문제가 발생했을 경우 빠르게 이전 버전으로 롤백할 수 있습니다. 롤아웃이 너무 빠르게 진행되면, 롤백하는 과정에서 복잡성이 증가할 수 있습니다.
- 데이터 마이그레이션: 데이터베이스 스키마 변경 등 데이터 마이그레이션을 안전하게 수행하기 위해 롤아웃 속도를 제어할 수 있습니다.
- 커스텀 메트릭 및 모니터링: 롤아웃 속도를 제어하면, 사용자 정의 메트릭이나 알림을 통해 시스템의 상태를 더 정확하게 모니터링 할 수 있습니다.
컴플라이언스 및 보안: 보안 팀이 새로운 변경 사항을 점검하거나, 컴플라이언스 요건을 충족시키기 위해 충분한 시간을 확보할 수 있습니다.
- 사용자 경험: 사용자에게 지속적으로 좋은 경험을 제공하기 위해, 롤아웃을 점진적으로 진행할 수 있습니다.
- 비용 절감: 불필요한 리소스 사용을 최소화하여 클라우드 비용이나 인프라 비용을 절감할 수 있습니다.


<img width="644" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/2fd5626f-888b-4010-863b-5a8c4e14a354">
<img width="713" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/5f7fbd28-5eeb-4ba3-9d29-5c0b616e9419">

#### maxUnavailable 속성이해 
디플로이먼트의 extentions/v1beta1 버전은 다른 기본 값을 사용.  
25% 대신 maxSurge 와 maxUnavailable을 1로 설정. 

<img width="581" alt="image" src="https://github.com/mason-ko/TIL/assets/30224146/32d87684-13ff-494b-af99-eafe273df243">

maxUnavailable은 원하는 레플리카 수에 비례한다.  

### 9.3.5 롤아웃 프로세스 일시 중지
#### 롤아웃 일시 정지
```
$ kubectl rollout pause deployment kubia
```
#### 롤아웃 재개 
```
$ kubectl rollout resume deployment kubia
```
#### 롤아웃을 방지하기 위한 일시 중지 기능 사용 
디플로이먼트 일시 중지 기능을 사용하면 롤아웃 프로세스삭 시작돼 디플로이먼트를 업데이트 하는것을 막을 수 있고,  
디플로이먼트를 여러 번 변경하면서 필요한 모든 변경을 완료한 후에 롤아웃을 시작하도록 할 수 있다.
### 9.3.6 잘못된 버전의 롤아웃 방지
minReadySeconds 속성으로 롤아웃 속도를 늦춰 롤링 업데이트 과정을 직접 볼 수 있고,  
해당 속성의 주요 기능은 오작동 버전의 배포를 방지하기 위함이다.  


## 9.4 요약

